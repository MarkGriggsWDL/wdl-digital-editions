name: Update latest.pdf from new issue

on:
  push:
    paths:
      - 'editions/*.pdf'          # any PDF under editions/
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: wdl-update-latest
  cancel-in-progress: true

jobs:
  update:
    # avoid loops on our own commits
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (with LFS)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Choose source PDF changed in this push (fallback to newest by git history)
        id: choose
        shell: bash
        run: |
          set -euo pipefail

          BEFORE="${{ github.event.before || '' }}"
          AFTER="${{ github.sha }}"

          echo "Finding changed PDFs between $BEFORE and $AFTER …"
          # List PDFs changed in this push, excluding editions/latest.pdf
          CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" -- 'editions/*.pdf' ':!editions/latest.pdf' || true)
          echo "Changed PDFs:"
          echo "$CHANGED"

          SRC=""
          if [ -n "$CHANGED" ]; then
            # If multiple changed, choose the one with the most recent commit time
            latest_ct=0
            for f in $CHANGED; do
              ct=$(git log -1 --format=%ct -- "$f" || echo 0)
              if [ "${ct:-0}" -gt "$latest_ct" ]; then
                latest_ct="$ct"
                SRC="$f"
              fi
            done
          fi

          if [ -z "$SRC" ]; then
            echo "No changed PDFs detected in this push; falling back to most recently updated by git history."
            # Among existing editions/*.pdf (excluding latest.pdf), pick the one with latest commit
            mapfile -t candidates < <(git ls-files 'editions/*.pdf' ':!editions/latest.pdf')
            if [ ${#candidates[@]} -eq 0 ]; then
              echo "No source PDFs found. Nothing to do."
              exit 0
            fi
            latest_ct=0
            for f in "${candidates[@]}"; do
              ct=$(git log -1 --format=%ct -- "$f" || echo 0)
              if [ "${ct:-0}" -gt "$latest_ct" ]; then
                latest_ct="$ct"
                SRC="$f"
              fi
            done
          fi

          echo "Chosen source PDF: $SRC"
          echo "src=$SRC" >> "$GITHUB_OUTPUT"

      - name: Copy → editions/latest.pdf and write provenance
        if: steps.choose.outputs.src != ''
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ steps.choose.outputs.src }}"
          echo "Copying $SRC → editions/latest.pdf"
          cp -f "$SRC" editions/latest.pdf
          ls -lh editions/latest.pdf

          BYTES=$(wc -c < editions/latest.pdf || echo 0)
          if [ "$BYTES" -lt 10240 ]; then
            echo "latest.pdf too small ($BYTES bytes) — aborting."
            exit 1
          fi

          basename "$SRC" > editions/latest.source.txt
          echo "Provenance:"
          cat editions/latest.source.txt

      - name: Commit (conflict-free) and push atop origin/main
        if: steps.choose.outputs.src != ''
        shell: bash
        env:
          GH_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"
          GH_NAME:  "github-actions[bot]"
        run: |
          set -euo pipefail
          git config user.email "$GH_EMAIL"
          git config user.name  "$GH_NAME"

          git add editions/latest.pdf editions/latest.source.txt

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git fetch origin main
          git reset --soft origin/main
          git commit -m "Update latest.pdf from $(cat editions/latest.source.txt)"
          git push origin HEAD:main
